# Solving Problems by Searching

![search](https://github.com/btdobbs/AI/blob/main/Topic/images/search.png)

## Agents that Plan

![agent-plans](https://github.com/btdobbs/AI/blob/main/Topic/images/agent-plans.png)

- **Theme**
  - Goal determination
  - Mathematical abstraction to formalize goal
  - Algorithms that operate on abstraction

### Reflex Agents

![agent-reflex](https://github.com/btdobbs/AI/blob/main/Topic/images/agent-reflex.png)

- Choose action based on current percept
- May have memory or a model of the world’s current state
- Do not consider the future consequences of their actions
- Consider how the world **is**
- Example
  - Eye blinking
  - Vacuum cleaner moving towards nearest dirt
- Can a reflex agent be rational?

**Demonstration: Pac-Man Optimal Reflex**

**Demonstration: Pac-Man Odd Reflex**

### Planning Agents

![agent-plan](https://github.com/btdobbs/AI/blob/main/Topic/images/agent-plan.png)

- Ask *what if*
- Decisions based on (hypothesized) consequences of actions
- Must have a model of how the world evolves in response to actions
- Must formulate a goal (test)
- Consider how the world **would be**
- Optimal vs. complete planning
- Planning vs. replanning

**Demonstration: Pac-Man Replanning**

**Demonstration: Pac-Man Mastermind**

## Search Problems

![agent-search](https://github.com/btdobbs/AI/blob/main/Topic/images/agent-search.png)

### Search Problems

- Search Problem Unpacking
  - State Space
  
    ![pac-man-sp-1](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-1.png)
    ![pac-man-sp-2](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-2.png)
    ![pac-man-sp-3](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-3.png)
    ![pac-man-sp-4](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-4.png)
    ![pac-man-sp-5](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-5.png)
    ![pac-man-sp-6](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-6.png)
    ![pac-man-sp-7](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-7.png)
  - Successor Function
    - Define Actions
    - Define Costs

    ![pac-man-sp-2](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-2.png)
    Action = North, Cost = 1
    ![pac-man-sp-3](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-3.png)
    
    ![pac-man-sp-2](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-2.png)
    Action = East, Cost = 1
    ![pac-man-sp-4](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-3.png)    
    
  - Start State

    ![pac-man-sp-1](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-1.png)
  - Goal State

    ![pac-man-sp-6](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-sp-6.png)
  - Solution

    A sequence of actions (i.e., a plan) which transforms the start state to a goal state.
    - East,1
    - North,1
    - West,2
    - South,2
    - East,2

### Search Problems are Models

![agent-world](https://github.com/btdobbs/AI/blob/main/Topic/images/agent-world.png)

### Example:  Romania Travel

![search-romania](https://github.com/btdobbs/AI/blob/main/Topic/images/search-romania.png)

|                        |                                                 |
| ---------------------- | ----------------------------------------------- |
| **State Space**        | Cities                                          |
| **Successor Function** | Roads: Go to adjacent city with cost = distance |
| **Start State**        | Arad                                            |
| **Goal State**         | Bucharest                                       |
| **Goal Test**          | state == Bucharest                              |

**Solution?**

### Pac-Man State Space

**World State**

![pac-man-world-state](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-world-state.png)

The **world state** includes every last detail of the environment.

A **search state** keeps only the details needed for planning (abstraction)

- Problem: Pathing
  - States: (x,y) location
  - Actions: NSEW
  - Successor: update location only
  - Goal test: is (x,y)=END

- Problem: Eat All Dots
  - States: {(x,y), dot booleans}
  - Actions: NSEW
  - Successor: update location and possibly a dot boolean
  - Goal test: dots all false  

![pac-man-state-size](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-state-size.png)

- World State
  - Agent Positions: 120
  - Food Count: 30
  - Ghost Positions: 12
  - Agent Facing: NSEW (4)

- Magnitude
  - World States: 120 x (2<sup>30</sup>) x (12<sup>2</sup>) x 4
  - Pathing States: 120
  - Eat All Dots States: 120 x (2<sup>30</sup>)

### Safe Passage

![pac-man-safe-passage](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-safe-passage.png)

- Problem: Eat all dots while keeping the ghosts perma-scared
- What does the state space have to specify?
  - Agent Position
  - Dot Booleans
  - Power Pellet Booleans
  - Remaining Scared Time

### State Space Graphs and Search Trees

![state-space-graph](https://github.com/btdobbs/AI/blob/main/Topic/images/state-space-graph.png)

### State Space Graphs

![pac-man-graph](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-graph.png)

- State space graph
  
  A mathematical representation of a search problem
  - Nodes are (abstracted) world configurations
  - Arcs represent successors (action results)
  - The goal test is a set of goal nodes (maybe only one)

- Each state occurs only once
- Building full graph in memory is a usefu idea, but it is rarely possible because it’s too big.

![tree-search-example](https://github.com/btdobbs/AI/blob/main/Topic/images/tree-search-example.png)

### Search Trees

![pac-man-search-tree](https://github.com/btdobbs/AI/blob/main/Topic/images/pac-man-search-tree.png)

- A *what-if* tree of plans and their outcomes
- The start state is the root node
- Children correspond to successors
- Nodes show states, but correspond to PLANS that achieve those states
- **For most problems, we can never actually build the whole tree**

Different plans that achieve the same state, will be different nodes in the tree.

### State Space Graphs vs. Search Trees

![state-search-graph](https://github.com/btdobbs/AI/blob/main/Topic/images/state-search-graph.png)
![state-search-tree](https://github.com/btdobbs/AI/blob/main/Topic/images/state-search-tree.png)

- Each NODE in in the search tree is an entire PATH in the state space graph.
- We construct both on demand – and we construct as little as possible.

### State Space Graphs vs. Search Trees

Consider the following 4-state graph:

![4-state-graph](https://github.com/btdobbs/AI/blob/main/Topic/images/4-state-graph.png)

How big is its search tree (from S)?

![4-state-graph-tree](https://github.com/btdobbs/AI/blob/main/Topic/images/4-state-graph-tree.png)

**Note:** A lot of repeated structure in the search tree due to loop

![inf](https://github.com/btdobbs/AI/blob/main/Topic/images/inf.png)

### Tree Search

![tree-search](https://github.com/btdobbs/AI/blob/main/Topic/images/tree-search.png)

### Example: Romania Search with a Search Tree

![search-romania](https://github.com/btdobbs/AI/blob/main/Topic/images/search-romania.png)

- Expand out potential plans (tree nodes)
- Maintain a **fringe** of partial plans under consideration
- Try to expand as few tree nodes as possible

![romania-search-1](https://github.com/btdobbs/AI/blob/main/Topic/images/romania-search-1.png)
![romania-search-2](https://github.com/btdobbs/AI/blob/main/Topic/images/romania-search-2.png)
![romania-search-3](https://github.com/btdobbs/AI/blob/main/Topic/images/romania-search-3.png)

### General Tree Search

```
function TREE-SEARCH(problem, strategy) returns a solution or failure
  initialize the search tree using the initial state of problem
  loop do
    if there are no candidate for expansion then return false
    choose a leaf node for expansion according to strategy
    if the node contains a goal state then return the corresponding solution
    else expand the node and add the resulting nodes to the search tree
  end
```

- Important ideas
  - Fringe
  - Expansion
  - Exploratoin strategy

- Main question
  - Which fringe nodes to explore

### Example: Tree Search

![tree-search-example-complete](https://github.com/btdobbs/AI/blob/main/Topic/images/tree-search-example-complete.png)
![tree-search-example-tree](https://github.com/btdobbs/AI/blob/main/Topic/images/tree-search-example-tree.png)
![tree-search-example-steps](https://github.com/btdobbs/AI/blob/main/Topic/images/tree-search-example-steps.png)

## Uninformed Search Problems

### Depth-First Search (DFS)

![dfs](https://github.com/btdobbs/AI/blob/main/Topic/images/dfs.png)

**Strategy:** Expand a deepest node first

**Implementation:** Fringe is a LIFO stack

![dfs-graph](https://github.com/btdobbs/AI/blob/main/Topic/images/dfs-graph.png)
![dfs-tree](https://github.com/btdobbs/AI/blob/main/Topic/images/dfs-tree.png)

### Search Algorightm Properties

![dfs-complete](https://github.com/btdobbs/AI/blob/main/Topic/images/dfs-complete.png)

- Complete: Guaranteed to find a solution if one exists?
- Optimal: Guaranteed to find the least cost path?
- Time complexity?
- Space complexity?

![search-alg-prop](https://github.com/btdobbs/AI/blob/main/Topic/images/search-alg-prop.png)

- b is the branching factor
- m is the maximum depth
- solutions at various depths

Number of nodes in entire tree = 1 + b + b<sup>2</sup> + .... + b^<sup>m</sup> = O(<sup>m</sup>)

### DFS Search Algorightm Properties

![dfs-search-alg-prop](https://github.com/btdobbs/AI/blob/main/Topic/images/dfs-search-alg-prop.png)

- What nodes DFS expand?
  - Some left prefix of the tree.
  - Could process the whole tree!
  - If m is finite, takes time O(b<sup>m</sup>)
- How much space does the fringe take?
  - Only has siblings on path to root, so O(bm)
- Is it complete?
  - m could be infinite, so only if we prevent cycles (more later)
- Is it optimal?
  - No, it finds the “leftmost” solution, regardless of depth or cost

### Breadth-First Search (BFS)

![bfs](https://github.com/btdobbs/AI/blob/main/Topic/images/bfs.png)

**Strategy:** Expand a shallowest node first

**Implementation:** Fringe is a FIFO queue

![tree-search-example](https://github.com/btdobbs/AI/blob/main/Topic/images/tree-search-example.png)

![bfs-tiers](https://github.com/btdobbs/AI/blob/main/Topic/images/bfs-tiers.png)

### BFS Search Algorightm Properties

![bfs-search-alg-prop](https://github.com/btdobbs/AI/blob/main/Topic/images/bfs-search-alg-prop.png)

- What nodes BFS expand?
  - Processes all nodes above shallowest solution
  - Let depth of shallowest solution be s
  - Search takes time O(b<sup>s</sup>)
- How much space does the fringe take?
  - Has roughly the last tier, so O(b<sup>s</sup>)
- Is it complete?
  - s must be finite if a solution exists, so yes
- Is it optimal?
  - Only if costs are all 1 (more on costs later)

### DFS vs BFS

- When will BFS outperform DFS?
- When will DFS outperform BFS?

**Demonstration: Maze Water BFS**

**Demonstration: Maze Water DFS**

### Iterative Deepening

![id-search](https://github.com/btdobbs/AI/blob/main/Topic/images/id-search.png)

- Idea: get DFS’s space advantage with BFS’s time / shallow-solution advantages
  - Run a DFS with depth limit 1.  If no solution…
  - Run a DFS with depth limit 2.  If no solution…
  - Run a DFS with depth limit 3.  …..

- Isn’t that wastefully redundant?
  - Generally most work happens in the lowest level searched, so not so bad!

### Cost-Sensitive Search

![cost-sensitive-search-graph](https://github.com/btdobbs/AI/blob/main/Topic/images/cost-sensitive-search-graph.png)

BFS finds the shortest path in terms of number of actions.  It does not find the least-cost path.  We will now cover
a similar algorithm which does find the least-cost path.  

### Uniform Cost Search (UCS)

![uc-search](https://github.com/btdobbs/AI/blob/main/Topic/images/uc-search.png)

**Strategy:** Expand a cheapest node first

**Implementation:** Fringe is a priority queue (priorty is a cumulative cost)

![uc-search-graph](https://github.com/btdobbs/AI/blob/main/Topic/images/uc-search-graph.png)

![uc-search-contour](https://github.com/btdobbs/AI/blob/main/Topic/images/uc-search-contour.png)

### UCS Search Algorightm Properties

![ucs-prop](https://github.com/btdobbs/AI/blob/main/Topic/images/ucs-prop.png)

- What nodes UCS expand?
  - Processes all nodes with cost less than cheapest solution
  - If that solution costs C* and arcs cost at least ε , then the “effective depth” is roughly C*/ε
  - Takes time O(b<sup>C*/ε</sup>) (exponential in effective depth)
- How much space does the fringe take?
  - Has roughly the last tier, so O(b<sup>C*/ε</sup>)
- Is it complete?
  - Assuming best solution has a finite cost and minimum arc cost is positive, yes
- Is it optimal?
  - Yes!  (Proof next discussion via A*)

### UCS Issues

![ucs-issue](https://github.com/btdobbs/AI/blob/main/Topic/images/ucs-issue.png)

- Remember: UCS explores increasing cost contours
- The good: UCS is complete and optimal!
- The bad:
  - Explores options in every “direction”
  - No information about goal location
  - Both of these issues can be fixed

**Demonstration: UCS**

### UCS vs BFS vs DFS

**Demonstration: Maze with Deep and Shallow Water - BFS**

**Demonstration: Maze with Deep and Shallow Water - UCS**

**Demonstration: Maze with Deep and Shallow Water - DFS**

### The One Queue

![one-queue-robot](https://github.com/btdobbs/AI/blob/main/Topic/images/one-queue-robot.png)

- All these search algorithms are the same except for fringe strategies
  - Conceptually, all fringes are priority queues (i.e. collections of nodes with attached priorities)
  - Practically, for DFS and BFS, you can avoid the log(n) overhead from an actual priority queue, by using stacks and queues
  - Can even code one implementation that takes a variable queuing object

![search-model-robot](https://github.com/btdobbs/AI/blob/main/Topic/images/search-model-robot.png)

- Search operates over models of the world
  - The agent doesn’t actually try all the plans out in the real world
  - Planning is all “in simulation”
  - Your search is only as good as your model…

### Search Issues

![search-gone-wrong](https://github.com/btdobbs/AI/blob/main/Topic/images/search-gone-wrong.png)

![search-gone-wrong-foot-path](https://github.com/btdobbs/AI/blob/main/Topic/images/search-gone-wrong-foot-path.png)

![search-gone-wrong-long-way](https://github.com/btdobbs/AI/blob/main/Topic/images/search-gone-wrong-long-way.png)

## Informed Search
